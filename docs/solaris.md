# Solaris backends: Event Ports and /dev/poll

Дата: 2025-10-23

Этот документ описывает текущее состояние бэкендов под Solaris/Illumos, их архитектуру, семантику таймаутов и пользовательских событий, а также советы по диагностике.

## Обзор и цели

- Поддерживаемые бэкенды: Event Ports (по умолчанию) и /dev/poll (fallback при `-DIO_WITH_EVENTPORTS=OFF`).
- Единая архитектура без фоновых потоков и лишних мьютексов:
  - Один поток с циклом `event_loop()`/`loop_once()`.
  - Пользовательские события для `post(uint32_t)` без потоков.
  - Idle‑таймауты чтения на сокетах реализованы через ближайший дедлайн, который задаёт таймаут блокирующего ожидания (`port_getn` или `DP_POLL`).

Цель — согласованность семантики с epoll/io_uring/kqueue: пауза/возобновление чтения, перезарядка idle‑дедлайна после успешного чтения, корректное закрытие по таймауту без гонок.

## Event Ports

- Ожидание событий: `port_getn()` с таймаутом, равным ближайшему дедлайну среди активных сокетов с включённым idle‑таймаутом.
- Пользовательские события: `port_send()` (источник `PORT_SOURCE_USER`), доставляются в `on_user` FIFO‑порядке.
- Модель «одиночной ассоциации» (one‑shot): после обработки `fd` переассоциируется через `port_associate()` с актуальной маской интересов.
- Idle‑таймауты:
  - Для каждого сокета храним `{timeout_ms, deadline, active}`.
  - После каждого успешного `read` дедлайн обновляется (rearm).
  - В `loop_once()` вычисляется ближайший дедлайн (ms) → передаётся как таймаут в `port_getn()`.
  - После обработки событий вызывается `close_expired(now)` — закрывает просроченные сокеты и вызывает `on_close`.
- Пауза/возобновление чтения:
  - При `pause_read(fd)` сокет исключается из интереса к чтению (не будет событий и не закроется по idle‑таймауту).
  - При `resume_read(fd)` интерес к чтению возвращается; дедлайн активируется/обновляется при первом чтении.

Включение расширенных логов: `-DIO_ENABLE_EVENTPORTS_VERBOSE=ON` (см. CMakeLists.txt). Логи печатаются в Debug‑сборках.

## /dev/poll

- Ожидание событий: `ioctl(DP_POLL)` с таймаутом по ближайшему дедлайну.
- Пользовательские события: внутренняя пользовательская труба используется для `post()` и пробуждения цикла; обработка аналогична epoll/kqueue.
- Idle‑таймауты:
  - Те же структуры `{timeout_ms, deadline, active}` и алгоритм: вычисляем ближайший дедлайн → задаём `dp_timeout`.
  - После обработки событий выполняем `close_expired(now)`.
- Пауза/возобновление чтения: меняем интересы (poll mask) и управляем дедлайнами как в Event Ports.

Включение расширенных логов: `-DIO_ENABLE_DEVPOLL_VERBOSE=ON`.

## Семантика и гарантии

- Idle‑таймаут чтения — это «idle» таймер: если за `timeout_ms` не пришло ни байта, сокет закрывается и вызывается `on_close`.
- Любое успешное чтение переармирует дедлайн.
- При `pause_read()` idle‑таймауты не закрывают сокет; при `resume_read()` отсчёт продолжится после возобновления активности.
- `post(value)` доставляется в порядке отправки; для /dev/poll используется внутренняя труба, для Event Ports — `port_send()`.

## Сборка и переключение бэкендов

По умолчанию включён Event Ports:

```bash
cmake -S . -B build/sol -DCMAKE_BUILD_TYPE=Debug -DIO_WITH_EVENTPORTS=ON
cmake --build build/sol -j
ctest --test-dir build/sol --output-on-failure
```

Для /dev/poll:

```bash
cmake -S . -B build/sol-dp -DCMAKE_BUILD_TYPE=Debug -DIO_WITH_EVENTPORTS=OFF
cmake --build build/sol-dp -j
ctest --test-dir build/sol-dp --output-on-failure
```

Готовые сценарии удалённой сборки/прогонов: `scripts/solaris/*.sh`.

## Диагностика

- Включите Debug‑сборку и при необходимости `IO_ENABLE_EVENTPORTS_VERBOSE` или `IO_ENABLE_DEVPOLL_VERBOSE`.
- Полезно логировать:
  - Для Event Ports: возвраты `port_getn` (количество событий), поля `portev_source`, `portev_events`, объект `portev_object`.
  - Для /dev/poll: маски `POLLIN`/`POLLOUT`/`POLLERR`/`POLLHUP` по каждому `fd`.
  - Переассоциацию/переподписку `fd` после обработки (one‑shot модель).
  - Завершение `connect` (`SO_ERROR`) — уже логируется в Debug.

## Известные замечания

- `port_getn` может возвращать `ETIME` при нулевом таймауте — обрабатываем как отсутствие событий, аналогично `EINTR`.
- При очень больших значениях idle‑таймаутов возможен небольшой джиттер из‑за округления миллисекунд; практическое влияние минимально.
